You are a senior full-stack engineer and migration specialist.
My project was migrated from one Replit account to another and now I am facing multiple issues across the entire application.

Your job is to perform a full static audit + repair of the project with a strong constraint:

‚ö†Ô∏è Important: I want to avoid wasting any Replit credits.
So:

Prefer static code analysis over running the code.

Do NOT run heavy scripts, full test suites, or infinite loops.

Only suggest commands that are safe and necessary, and clearly label them as ‚Äúoptional to run‚Äù.

0. Project context

Treat this as the project description (update this section based on my stack if needed):

Hosting: Replit

Backend: Node.js with Express (assume typical REST APIs)

Frontend: React (SPA / multi-page as per code)

Database: Use what you detect from the code (Prisma / MongoDB / PostgreSQL / etc.)

Build tools: Detect from the code (Vite, CRA, Next.js, etc.)

You must infer the stack and tools from the codebase, not guess blindly.

1Ô∏è‚É£ Overall Strategy (MANDATORY)

Follow this high-level approach:

Do a static scan first, going through:

package.json / requirements.* / lock files

index / main / server / app files

Environment variable usage

Database configuration and schemas

Routes / controllers / services

Frontend entry points and routing

Shared components and layout wrappers

List all issues you see or expect, including:

Current errors visible in the code

Potential runtime errors

Misconfigurations after migration (paths, env, domains, keys)

Mobile/responsive issues

Performance or obvious bad patterns

Warnings that will show in console or logs

For each issue, provide:

File path

Exact line or code snippet that is wrong

Root cause (why it breaks, especially after migration)

Full corrected code block (not just diff)

Short explanation of the fix

Do not assume any file is correct.
Check:

Every import

Every route

Every query

Every major component

All env usages

All external URLs

If code is missing or something is unclear, ask me to upload the specific files you need instead of guessing.

2Ô∏è‚É£ Backend: Exhaustive Checklist & Fixes

Go through all backend files and handle all of this in detail:

2.1. Environment & Configuration

Find all places using process.env.* or similar.

Identify:

Which env vars are required

Which ones are optional

For each env var:

Tell me: name, purpose, where used

Check for undefined risk and add safe defaults or validation where needed.

If Replit uses a different env system, explain clearly:

Where to set each env var in Replit

What default or dummy value I can use for local testing.

2.2. Server Setup

Inspect server entry files like:
server.js, index.js, app.js, main.ts, etc.

Check for:

Incorrect ports or hardcoded hostnames

localhost references that should be dynamic

CORS configuration (origins updated after migration)

Wrong paths to static assets

Middleware order (e.g., body-parser, cors, session, helmet)

For each found issue:

Show the original code

Then provide full corrected server setup code.

2.3. Routing & Controllers

List all API routes: methods + paths (e.g., GET /api/users, POST /api/login).

For each route:

Verify the handler exists and is imported correctly.

Ensure the path in frontend matches backend (no /api mismatch, no trailing slash issue).

Check error handling: avoid unhandled promise rejections.

Confirm correct use of async/await and try/catch.

If any route is broken, missing or miswired:

Provide the fixed router file and fixed controller code.

Explain what was wrong and how migration could have caused it (e.g., different folder structure, case-sensitivity).

2.4. Database Layer

Infer DB type from code and then:

Check DB connection config:

Connection string (URL)

Host, port, user, password, DB name

SSL flags or special options (e.g., for hosted DBs)

Check ORM / driver specifics:

Prisma: schema.prisma, migrations, prisma client import, env var DATABASE_URL.

Mongoose: mongoose.connect, model definitions, connection options.

Sequelize / TypeORM / others: configs, models, migrations.

For each issue, such as:

Wrong env var name (DB_URL vs DATABASE_URL)

Old URL pointing to previous account or DB

Missing migrations or sync steps

You must:

Show the existing wrong code/config

Provide the corrected config, including:

Corrected schema or model

Corrected connection code

Any migration / sync command I may need to run (tag as ‚Äúoptional command‚Äù).

2.5. Queries & Business Logic

For every query or DB call:

Check that:

The collection/table exists in schema

Field names match what‚Äôs in models

Error handling exists (try/catch or .catch)

No unchecked null or undefined usage

If anything could crash at runtime:

Update the code to safely handle missing data.

Provide the full safe function implementation.

3Ô∏è‚É£ Frontend: Exhaustive Checklist & Fixes

Go through all frontend code:

3.1. Entry Points & Routing

Identify main entry files:
index.js, main.jsx, App.jsx/tsx, pages/_app.* (if Next.js), etc.

Check:

React / framework version compatibility

Correct root render (ReactDOM.createRoot, etc.)

Router version (React Router v5 vs v6 usage)

All route paths actually exist.

Fix any:

Incorrect imports

Mismatched filenames (case-sensitive)

Route paths not matching backend APIs

3.2. API Calls from Frontend

Find all usages of fetch, axios, apiClient, etc.

For each:

Ensure the base URL is correct for Replit environment.

Avoid hardcoded localhost:3000 if backend is deployed under different URL.

Handle errors:

try/catch

User-facing error messages

Avoid crashing the UI.

Provide:

A centralized API helper (if missing) that:

Has a configurable base URL

Standardized error handling

Optional auth header handling.

3.3. Components & State

Scan all components for:

Incorrect prop types

Missing null checks (e.g., data && data.map(...))

State updates that can cause errors after migration.

Fix:

Any direct DOM access that might fail on first render.

Any hooks used conditionally (violating rules of hooks).

Any infinite render loops (setState in render path without condition).

Return full corrected components, not partial snippets.

4Ô∏è‚É£ UI, Layout, and Responsiveness (Desktop ‚Üí Tablet ‚Üí Mobile)

You must treat responsiveness as a first-class task, not an afterthought.

4.1. Layout System

Detect layout approach:

CSS modules, Tailwind, Styled-components, plain CSS, SCSS, etc.

For each page:

Check if layout uses flex, grid, or absolute positioning.

Ensure containers don‚Äôt have fixed widths that break on small screens.

Replace fixed pixel widths/heights with responsive units where needed.

4.2. Breakpoints

Identify any media queries or framework breakpoints.

For each major screen size:

Large desktop

Laptop

Tablet

Mobile (small, medium)

Check and fix:

Overflow issues (overflow-x scrolling when not desired).

Text overflowing outside its container.

Images not scaling or stretching weirdly.

Elements overlapping due to absolute positioning.

Where necessary, rewrite CSS or component structure and provide:

Full updated JSX + CSS / Tailwind classes.

4.3. Navigation & Menus on Mobile

Check any navbar / sidebar / drawer component:

Does the hamburger menu work?

Does the menu close on navigation?

Is the clickable area large enough?

Fix any issues and provide the entire corrected component.

5Ô∏è‚É£ Animations & Interactions

If the project uses Framer Motion, GSAP, or CSS animations:

Make sure:

No animation code runs on the server (if SSR).

Access to window or document is guarded (if (typeof window !== 'undefined')).

Timelines and variants are properly defined.

Animations don‚Äôt break layout or block scrolling on mobile.

Fix:

Any incorrect imports.

Any invalid props or API usage.

Any heavy animation causing performance issues.

Provide:

Cleaned-up animation code for each animated component.

6Ô∏è‚É£ Assets, Paths & Static Content

Migration often breaks file paths.

Check:

All imports like import img from '../assets/...'

All <img src="/something"> paths

Fonts, icons, and other static resources.

For each missing or broken asset:

Adjust paths to match the current folder structure.

If a file is truly missing:

Tell me exactly which file is missing and from where.

Suggest a fallback or placeholder.

7Ô∏è‚É£ Error Handling, Logging & Stability

Add/verify a global error handler in backend:

For unhandled errors

For 404 routes

For validation errors

In frontend:

Add at least one error boundary for critical sections (if React).

Make sure failed API calls show a user-friendly message and not a blank/broken UI.

8Ô∏è‚É£ Commands & Replit-Specific Notes (No Waste of Credits)

At the end, provide a safe, minimal, optional set of commands:

For installing dependencies

For migrating or syncing the DB

For running the dev / prod server

Each command should be clearly tagged:

# Optional ‚Äì may cost compute/credits on Replit

# Recommended ‚Äì necessary to apply DB changes

# Light ‚Äì low impact command

Do NOT assume I want to run heavy scripts automatically.
Your job is to describe, not execute.

9Ô∏è‚É£ Final Deliverables

When you‚Äôre done, your answer must include:

A table/list of all issues found, grouped by:

Backend

Database

Frontend logic

UI/layout/responsiveness

Animations & interactions

Config/environment

For each issue:

File path

Problem description

Root cause (including why migration caused it)

Full fixed code snippet

A ‚ÄúHow to get running again‚Äù section:

Env vars I must set (with example values)

Setup steps in Replit

Optional commands to run (clearly labeled)

A short section of future-proof suggestions:

Folder structure improvements

Config improvements

Anything that will reduce future errors after changes or migrations.

üß© How to Start

Your first response to this prompt should be:

Confirm you understand all constraints (especially no unnecessary actions that waste credits).

Ask me to upload:

package.json (and lock files)

Backend source files

Frontend source files

Database schema/migration files

Any config/env template files

Then start the analysis and fixes step by step.